# Skeldir API Domain Invariants Registry
# Version: 1.0
# Purpose: Centralized definition of business invariants that must be enforced
#          across contracts, database constraints, Pydantic models, and tests

domain_invariants:
  # Currency Constraints
  currency:
    type: string
    pattern: "^[A-Z]{3}$"
    description: "ISO 4217 uppercase 3-letter currency code (e.g., USD, EUR, GBP)"
    rationale: "Ensures currency consistency across all revenue and transaction data"
    enforcement_points:
      - contract: "All currency fields in request/response schemas"
      - db: "CHECK constraint on currency columns"
      - pydantic: "Field validator with regex pattern"
      - tests: "Test cases with invalid currencies (lowercase, 2-letter, 4-letter)"
    exceptions:
      - platform: "stripe"
        pattern: "^[a-z]{3}$"
        rationale: "Stripe API uses lowercase currency codes per their specification"
    
  currency_stripe:
    type: string
    pattern: "^[a-z]{3}$"
    description: "ISO 4217 lowercase 3-letter currency code for Stripe (e.g., usd, eur, gbp)"
    rationale: "Stripe's API specification requires lowercase currency codes"
    enforcement_points:
      - contract: "Stripe webhook currency fields only"
      - pydantic: "Stripe-specific Pydantic models"
      - tests: "Stripe-specific test cases"
  
  # Bayesian Model Outputs
  confidence_score:
    type: number
    format: double
    minimum: 0
    maximum: 1
    description: "Bayesian confidence score representing probability [0, 1]"
    rationale: "Statistical validity requires probabilities in unit interval"
    enforcement_points:
      - contract: "Future attribution endpoints (B2.4+)"
      - pydantic: "Field validator with range check"
      - tests: "Boundary testing at 0, 0.5, 1, and invalid values"
  
  credible_interval_lower:
    type: number
    format: double
    minimum: 0
    description: "Lower bound of Bayesian credible interval (must be ≥ 0)"
    rationale: "Revenue values cannot be negative"
    enforcement_points:
      - contract: "Optional field for future Bayesian models (B2.4+)"
      - pydantic: "Validator ensuring lower < upper when both present"
  
  credible_interval_upper:
    type: number
    format: double
    minimum: 0
    description: "Upper bound of Bayesian credible interval (must be ≥ 0)"
    rationale: "Revenue values cannot be negative"
    enforcement_points:
      - contract: "Optional field for future Bayesian models (B2.4+)"
      - pydantic: "Validator ensuring lower < upper when both present"
  
  # Data Freshness & Timing
  data_freshness_seconds:
    type: integer
    minimum: 0
    description: "Non-negative seconds since data was last updated"
    rationale: "Time intervals cannot be negative; ensures freshness metrics are meaningful"
    enforcement_points:
      - contract: "Attribution realtime revenue response"
      - pydantic: "Field validator with minimum=0"
      - tests: "Test with 0 (just updated), typical values, very large values"
  
  event_timestamp:
    type: string
    format: date-time
    description: "RFC 3339 UTC timestamp (e.g., '2025-11-10T14:30:00Z')"
    rationale: "Ensures consistent timestamp format for event ordering and reconciliation"
    enforcement_points:
      - contract: "All webhook event timestamps, reconciliation timestamps"
      - db: "TIMESTAMPTZ columns with UTC enforcement"
      - pydantic: "datetime field with timezone awareness validation"
      - tests: "Various formats (valid RFC 3339, invalid formats, timezone variations)"
  
  # Revenue & Monetary Values
  total_revenue:
    type: number
    format: double
    minimum: 0
    description: "Total revenue in dollars (non-negative floating point)"
    rationale: "Revenue aggregations cannot be negative (refunds handled separately)"
    enforcement_points:
      - contract: "Attribution realtime revenue response"
      - pydantic: "Field validator with minimum=0"
      - tests: "Zero revenue, typical values, very large values, precision handling"
    note: "Currently incorrectly typed as 'string' in attribution.yaml - will be fixed in G4"
  
  transaction_amount_cents:
    type: integer
    minimum: 0
    description: "Transaction amount in smallest currency unit (cents, pence, etc.)"
    rationale: "Monetary values stored as integers to avoid floating-point precision issues"
    enforcement_points:
      - db: "INTEGER columns for amounts with CHECK constraint >= 0"
      - pydantic: "int field with validator"
      - tests: "Zero amount, typical values, maximum int values"
  
  # Identifiers
  tenant_id:
    type: string
    format: uuid
    description: "Tenant identifier (UUID v4 format)"
    rationale: "Multi-tenant isolation requires consistent UUID format for partitioning"
    enforcement_points:
      - contract: "All authenticated response schemas"
      - db: "UUID primary key or foreign key"
      - pydantic: "UUID field type"
      - tests: "Valid UUIDs, invalid formats, null handling"
  
  correlation_id:
    type: string
    format: uuid
    description: "Distributed tracing correlation ID (UUID v4 format)"
    rationale: "Enables request tracing across services for debugging and audit"
    enforcement_points:
      - contract: "X-Correlation-ID header in all endpoints"
      - middleware: "Auto-generation if not provided by client"
      - logs: "Included in all structured log entries"
      - tests: "Header presence, propagation across service boundaries"
  
  error_id:
    type: string
    format: uuid
    description: "Unique error occurrence identifier (UUID v4 format)"
    rationale: "Enables precise error tracking and customer support"
    enforcement_points:
      - contract: "Problem schema extension (RFC 7807)"
      - error_tracking: "Error database with error_id as key"
      - tests: "Error ID uniqueness, presence in error responses"
  
  # Platform-Specific Identifiers
  shopify_order_id:
    type: integer
    minimum: 1
    description: "Shopify order ID (positive integer, used for idempotency)"
    rationale: "Shopify uses integer IDs; ensures valid idempotency key"
    enforcement_points:
      - contract: "Shopify webhook request schemas"
      - db: "Idempotency table with Shopify order ID"
  
  woocommerce_order_id:
    type: integer
    minimum: 1
    description: "WooCommerce order ID (positive integer, used for idempotency)"
    rationale: "WooCommerce uses integer IDs; ensures valid idempotency key"
    enforcement_points:
      - contract: "WooCommerce webhook request schemas"
      - db: "Idempotency table with WooCommerce order ID"
  
  stripe_charge_id:
    type: string
    pattern: "^ch_[a-zA-Z0-9]+$"
    description: "Stripe charge ID (format: 'ch_' followed by alphanumeric)"
    rationale: "Stripe's ID format ensures valid idempotency key"
    enforcement_points:
      - contract: "Stripe webhook request schemas"
      - db: "Idempotency table with Stripe charge ID"
  
  paypal_transaction_id:
    type: string
    minLength: 1
    description: "PayPal transaction ID (string, used for idempotency)"
    rationale: "PayPal uses string IDs; ensures non-empty idempotency key"
    enforcement_points:
      - contract: "PayPal webhook request schemas"
      - db: "Idempotency table with PayPal transaction ID"
  
  # State & Status Enums
  reconciliation_state:
    type: string
    enum:
      - idle
      - running
      - completed
      - failed
    description: "Reconciliation pipeline state machine values"
    rationale: "Finite state machine requires explicit state enumeration"
    enforcement_points:
      - contract: "Reconciliation status response schema"
      - db: "ENUM or CHECK constraint on state column"
      - pydantic: "Literal type with enum values"
      - tests: "All valid states, invalid state rejection"
  
  export_format:
    type: string
    enum:
      - json
      - csv
    description: "Data export format options"
    rationale: "Limits export formats to supported types"
    enforcement_points:
      - contract: "Export API format query parameter"
      - backend: "Export handler format switch"
  
  token_type:
    type: string
    enum:
      - Bearer
    description: "OAuth 2.0 token type (currently only Bearer supported)"
    rationale: "OAuth 2.0 spec compliance"
    enforcement_points:
      - contract: "Authentication response schemas"
      - tests: "Token type validation in auth tests"
  
  verified_status:
    type: boolean
    description: "Whether revenue data has been verified through reconciliation pipeline"
    rationale: "Binary state for data trustworthiness indicator"
    enforcement_points:
      - contract: "Attribution realtime revenue response"
      - db: "BOOLEAN column with NOT NULL constraint"
      - pydantic: "bool field"
  
  # Pagination
  pagination_limit:
    type: integer
    minimum: 1
    maximum: 100
    default: 50
    description: "Maximum items per page in paginated responses"
    rationale: "Prevents excessive data transfer and database load"
    enforcement_points:
      - contract: "Pagination parameter in export endpoints"
      - backend: "Query limit enforcement"
      - tests: "Boundary testing at 1, 50, 100, 101 (invalid)"
  
  pagination_cursor:
    type: string
    format: base64
    description: "Opaque cursor for pagination (base64-encoded)"
    rationale: "Cursor-based pagination for large datasets without offset skew"
    enforcement_points:
      - contract: "Pagination parameter and response"
      - backend: "Cursor encoding/decoding logic"
      - tests: "Cursor validity, expiration, tampering detection"

# Validation Rules
validation_rules:
  - name: "Currency Format Consistency"
    description: "All currency fields must match the appropriate invariant (uppercase for most, lowercase for Stripe)"
    check: "Scan all contract schemas for 'currency' fields and validate pattern constraint"
  
  - name: "Non-Negative Monetary Values"
    description: "All revenue and amount fields must have minimum: 0 constraint"
    check: "Scan contracts for revenue/amount/total fields and validate minimum constraint"
  
  - name: "UUID Format Consistency"
    description: "All ID fields with 'id' suffix and tenant_id/correlation_id/error_id must use format: uuid"
    check: "Scan contracts for UUID-named fields and validate format constraint"
  
  - name: "Timestamp Format Consistency"
    description: "All timestamp fields must use format: date-time (RFC 3339)"
    check: "Scan contracts for timestamp/created_at/updated_at fields and validate format"
  
  - name: "Enum Completeness"
    description: "All state/status fields must use explicit enum constraints, not loose strings"
    check: "Scan contracts for state/status/type fields and ensure enum or pattern constraint"

# Enforcement Automation
enforcement_automation:
  spectral_rules:
    - rule: "no-unconstrained-currency"
      description: "Currency fields must have pattern constraint matching invariant"
      severity: error
    
    - rule: "no-negative-monetary-values"
      description: "Revenue/amount fields must have minimum: 0"
      severity: error
    
    - rule: "uuid-format-required"
      description: "ID fields must use format: uuid"
      severity: error
    
    - rule: "timestamp-format-required"
      description: "Timestamp fields must use format: date-time"
      severity: error
    
    - rule: "no-loose-state-strings"
      description: "State/status fields must use enum constraints"
      severity: error
  
  python_validators:
    - script: "scripts/governance/validate-invariants.py"
      description: "Scans all bundled contracts and validates field constraints against registry"
      exit_code: 1 if any invariant violations found

# Changelog
changelog:
  - version: "1.0"
    date: "2024-01-15"
    changes: "Initial invariants registry created from empirical contract analysis"
    author: "API Governance Lead"





